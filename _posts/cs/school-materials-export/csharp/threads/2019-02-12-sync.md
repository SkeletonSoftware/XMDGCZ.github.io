## Synchronizace vláken

Nejdůležitější při práci s vlákny je zajištění synchronizace. V případě efektivní spolupráce, je dosaženo ideálního cíle.

V praxi se většina programátorů spokojí s Thread-Safe třídami.

**Thread-Safe** třída, je ta třída, která kromě běžných přístupových rozhraní ještě počítá se simultánním používáním více vlákny, také se používá klíčové slovo **synchronized**.

Uvažme následující příklad:

    <code class="language-C# ">static bool check;
    static void Main()
    {
        new Thread (SomeMethod).Start();
        SomeMethod();
    }
    static void SomeMethod()
    {
        if (!check)
        {
            check = true;
            Console.WriteLine ("Done"); 
        }
    }
    </code>

Nejdříve se vytvoří a spustí nové vlákno s metodou, která zjišťuje podmínku a poté vypisuje do konzole zprávu. Simultánně v hlavním vlákně se volá ta samá metoda.

V jednu chvíli se ke zpracování připraví dvě metody. Čteme-li kód odshora dolů, lze si odvodit, že jako první je zpracována metoda v separátním vlákně.  
 Obě metody pracují se stejnou proměnnou check.

Při provedení metody v separátním vlákně se změnila hodnota check a vypsala se na obrazovku zpráva, při zpracování té samé metody se díky podmínce již žádná zpráva nevypsala.

Otočíme-li pořadí check = true a Console.WriteLine():

    <code class="language-C# ">static bool check;
    static void SomeMethod()
    {
        if (!check)
        {
            Console.WriteLine ("Done"); 
            check = true;
        }
    }
    </code>

Stane se, že zpráva **může** být na obrazovku vypsána 2x, kvůli tomu, že jedna metoda může již vyhodnotit podmínku a druhá teprve ovlivňovat proměnnou check.

Tento způsob lze přirovnat ke skákání do řeči v rozhovoru.

### Lock

Jsou případy, kdy skákání do řeči nevadí, ale jsou i takové, které mohou narušit celý koncept, jako u příkladu výše, kde chceme vypsat zprávu pouze jednou.

Označíme-li určitý kus kódu za kritický (blok, který musí být proveden bez ovlivňování) je nutné ho určitým způsobem uzamknout.

K tomu slouží klíčové slovo lock() a objekt, který slouží jako vrátný. Tento objekt může být libovolného typu, funguje pouze jako hradba.

    <code class="language-C# ">static bool check;
    static Object locker = new Object();

    static void Main()
    {
        new Thread (SomeMethod).Start();
        SomeMethod();
    }

    static void SomeMethod()
    {
        lock (locker)
        {
            if (!check)
            { 
                Console.WriteLine ("Done");
                check = true; 
            }
        }
    }
    </code>

Pokud jedno vlákno vstoupí do kritické sekce, druhé se do ní nedostane, dokud první nedokončí svou činnost.

Nejčastější chyby při multitaskingu vznikají právě kvůli špatnému zacházení se sdílenými daty. Je několik způsobů, jak vytvořit Thread-Safe aplikaci při použití lock().

*   Zamknutí kritické části metody viz. příklad výše
*   Zamknutí přístupového rozhraní dat

#### Zamknutí přístupového rozhraní

Zamykání přístupového rohraní je vhodné pouze tehdy, pokud je nutné provést činnost, která není atomická. Atomická činnost je čtení, nebo zapisování, to ale neplatí u určitých datových typů.  
 Například zapisování do Int32 je jedna instrukce do procesoru, pokud je použit 32bit systém, zapisování do Int64 na 32bit operačním systému jsou operace dvě. V druhém případě se tedy nejedná o atomickou operaci.

Důležité je také použití klíčového slova **volatile**, které varuje kompiler před tím, že daná proměnná může být měněna z více vláken např. by se nemělo stávat, že se bude daná proměnná Cachovat.

    <code class="language-C# ">class DataStore
    {
        private volatile int cislo;
        private object locker = new object();
        public int Cislo
        {
            get
            {
                int result;
                lock (locker)
                {
                    result = cislo;
                }
                return result;
            }
            set
            {

                lock(locker) cislo = value;
            }
            // Čtení a zároveň zápis do jedné proměnné je nebezpečné
            // Proto je použit vždy stejný zámek
        }
    }
    </code>

Tento způsob má své výhody, protože v jednu chvíli není možné číst a zároveň zapisovat do proměnné, ale jako častější se zamyká volání samotných metod jako v 1. příkladu.

*Pozn. použití lock() je svázané s instancí aplikace, je-li nutné použití systémového objektu, který existuje napříč prostředím, je k tomu navržen Mutex. Tedy synchronizace mezi procesy.*
---
layout: post
title: "Selection sort "
categories:
    - "csharp"
    - "algs"
sort_index: 2
author: "David Malý"
--- 


## Selection sort


Algoritmus, který využívá základní vlastnosti posloupnosti hodnot, kde je jedna hodnota různá od následující dle stálého pravidla



Např. řazení od nejmenšího prvku po největší znamená, že nejmenší prvek je jako první. Větší prvek než první, ale menší než třetí je druhý atd.
Na základě této vlastnosti stačí nalézt vhodný prvek a zařadit jej na správné místo.


Základní vlastnosti
- Stabilita: **nestabilní**
- Složitost: **O(n^2)**
- Paměťová náročnost: **konstantní**
- Přirozenost: **přirozený**


### Princip řazení


Máme k dispozici data ve formě pole.
Algoritmus čte pole tolikrát, kolik má prvků. Nejprve **zvolíme 1. prvek pole jako pivot** (prvek, se kterým ostatní prvky porovnáváme) a poté **hledáme prvek, který je větší** (dle řazení), najdeme-li takový**, určíme ho jako pivot**. Tímto způsobem najdeme největší prvek v poli.
Po přečtení celého pole **provedeme záměnu  1. prvku s nalezeným největším prvkem** v poli (poslední pivot).
Abychom seřadili celé pole, je nutné tento postup opakovat tolikrát, kolik má pole prvků. Můžeme s jistotou říci, že po provedení záměny, je již daný prvek správně zařazen, proto ho nemusíme znovu určovat jako pivot a jednoduše určíme jako pivot prvek následující.


### Vizualizace

- Menší ze dvou prvků se barví do Červená a posouvá se doprava.
- Některé prvky zůstanou po seřazení červené, to je dáno právě stabilitou algoritmu, kde stejné prvky nejsou zpracovávány a dochází k jejich přeskočení. Tyto prvky byly posunuty rovnou na správné místo.
- Některé prvky si po určitou dobu zachovají bílou barvu, to je dáno tím, že v dané chvíli byly již správně seřazeny a mohly být tedy přeskočeny. Některé z nich jsou bílé po celou dobu řazení, to znamená, že jsou již od začátku algoritmu na správném místě -> **řada je částečně seřazená => algoritmus je přirozený**.

 

### Zdrojový kód

```

// Proveď pro cele pole
for(int i = 0; i < array.Length-1; i ++)
{// Urči pivotint pivot = i;
// Pro cele pole od prvku určený jako pivotfor(int j = i+1; j  array[pivot]) pivot = j;}// Záměna posledního pivota s prvním pivotemint temp = array[pivot];array[pivot] = array[i];array[i] = temp;
}

```


Stabilní verzí je: [Bing sort](https://en.wikipedia.org/wiki/Selection_sort)


*Pozn. V obecném měřítku je rychlejší než Bubble sort, ale pomalejší než Insertion sort.
Vhodný pokud situace vyžaduje co nejméně zápisů do paměti např. řazení souborů na SSD disku nebo jiné paměti.*

 Odkazy pro rozšíření daného téma:

[ITnetwork](http://www.itnetwork.cz/algoritmy/razeni/algoritmus-selection-sort-razeni-cisel-podle-velikosti/)[Algoritmy.net](https://www.algoritmy.net/article/4/Selection-sort)
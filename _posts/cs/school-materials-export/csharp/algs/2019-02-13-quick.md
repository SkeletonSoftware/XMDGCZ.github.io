---
layout: post
title: "quick.php "
categories:
    -"csharp"
    -"csharp"
author: "David Malý"
--- 


## Quick sort


Algoritmus fungující na principu rozděl a panuj (nejde-li daný problém řešit, rozložíme ho na menší již řešitelné části). 
<br>V současnosti se jedná o jeden z nejrychlejších univerzálních řadících algoritmů.<br>
Základní vlastnosti


- Stabilita: **nestabilní**
- Složitost: **O(n \* log n)**
- Paměťová náročnost: v nejhorším případě **lineární**, po optimalizacích dodatečnou paměť skoro nepotřebuje
- Přirozenost: **není přirozený**


### Princip řazení


Základní myšlenkou tohoto algoritmu je práce s pivotem. Pivot je jeden z prvků neseřazeného pole, se kterým porovnáváme okolní prvky. 
<br>Principiálně je postup takový:


- Zvolíme pivot
- Seřazení pole na prvky např. menší vlevo a větší vpravo od pivota tak, že se vymění pivot s vhodným prvkem
- Poté se vlevo i vpravo zvolí další pivoty a okolo nich se pole opět přeskupí
- Algoritmus končí ve chvíli, kdy pro volbu pivota zbyla pouze jednoprvková pole



Činnost algoritmu je tedy rozdělena na dvě části a opakování:


- Volba pivota
- Seřazení okolí vůči pivotu
- Opakování celého postupu pro části vlevo i vpravo od pivota



#### - Volba pivota



Využívá se několik způsobů volby.


  - Nejjednodušší je zvolit náhodný prvek. Tento způsob je efektivní a často používaný.
  - Sofistikovanější způsob je zvolit vždy prostřední prvek, nebo jemu blízký. Tím je možné dosáhnout nejefektivnější složitosti algoritmu





*Pozn.  u většiny algoritmů, které dělí pole, je nejlepší pole rozdělovat pokud možno na poloviny*


#### - Seřazení okolí pivota



Všechny prvky v okolí pivota se s daným pivotem porovnají a umístí se buď vlevo nebo vpravo od něj. Na pořadí nezáleží.


#### - Opakování postupu



Po volbě pivota a přeskupení prvků vlevo a vpravo od něj se rozdělilo původní pole na dvě části. Pro každou část opakuje znovu všechny kroky, tedy v každé části zvolíme pivot a opět pole přeskupíme. 
<br>Postupným dělením vstupního pole ve výsledku zůstanou pouze jednoprvková pole a v tu chvíli je již celé pole seřazené a algoritmus končí. 
<br>Nevýhodou může být při neefektivní volbě pivota vzrůstající paměťová náročnost.



### Vizualizace
![](images/QuickSoer.png)
### Zdrojový kód


Zdrojový kód je stejně jako postup algoritmu rozdělen na dvě části:


1. Metoda na dělení pole na dvě části, která umisťuje prvek na správné místo a vrací jeho pozici - Partition(pole, zacatekLevehoPole, konecPravehoPole)
2. Metoda pro rekurzivní volání dělení pole na části a hledání pivota - QuickSort\_Recursive(pole, zacatekLevehoPole, konecPravehoPole)



```

/// Rozdělí pole na dvě části, seřadí je a celou proceduru opakuje
/// Pole k seřazení
/// Začátek části pole
/// Konec části pole
public static void QuickSort(int[] arr, int left, int right)
{// Rekurze se zastaví pokud je začátek a konec pole stejný => jednoprvková nebo prázdná poleif (left < right){	// Rozdělení pole na dvě části a získání pivota	int partitionIndex = Partition(arr, left, right);   	// Opakování pro obě části pole => rekurze	QuickSort(arr, left, partitionIndex - 1);	QuickSort(arr, partitionIndex + 1, right);}
}
/// Určí pivot, podle něj rozdělí pole na dvě části
/// Pole k seřazení
/// Začátek části pole - index
/// Konec části pole - index
/// Vrací pozici pivota
private static int Partition(int[] arr, int left, int right)
{// Pivo je poslední prvekint pivot = arr[right];int temp;// Začátek poleint i = left;// Pro celou část polefor (int j = left; j < right; j++){	// Porovnání hodnoty s pivotem	if (arr[j] <= pivot)	{		// Pokud je prvek menší než pivot, tak je vymění		temp = arr[j];		arr[j] = arr[i];		arr[i] = temp;		i++;	}}arr[right] = arr[i];arr[i] = pivot;return i;
}

```


*Pozn. Velká rychlost algoritmu je vyvážena jeho neefektivností na částečně seřazených polích*

Vylepšenou verzí je QuickSort 3, který rozděluje pole na menší, stejné a větší prvky.<br>

 Odkazy pro rozšíření daného téma:

[ITnetwork](http://www.itnetwork.cz/algoritmy/razeni/algoritmus-quick-sort-razeni-cisel-podle-velikosti/)[Algoritmy.net](https://www.algoritmy.net/article/10/Quicksort)
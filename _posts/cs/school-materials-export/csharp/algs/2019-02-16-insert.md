---
layout: post
title: "Insertion sort "
categories:
    - "csharp"
    - "algs"
sort_index: 3
author: "David Malý"
--- 


## Insertion sort


Algoritmus fungující na principu rozděl a panuj (nejde-li daný problém řešit, rozložíme ho na menší již řešitelné části). V tomto případě vidíme, že se pole dat skládá ze setříděné a nesetříděné části.
Hledá prvek, který se shoduje s podmínkou řazení, a poté pro něj hledá vhodné místo v již setříděné části pole.



Základní vlastnosti


- Stabilita: **stabilní**
- Složitost: **O(n^2)**
- Paměťová náročnost: **konstantní**
- Přirozenost: **přirozený**


### Princip řazení


Máme k dispozici data ve formě pole.
Algoritmus čte pole tolikrát, kolik má prvků. Považuje 1. prvek pole za setříděnou část a tak se zabývá prvkem následujícím, ten si uloží do paměti, poté **hledá v setříděné části pole vhodnou pozici pro zařazení vybraného prvku**. 
Hledání probíhá pomocí porovnávání prvků v setříděné části pole s vybraným prvkem. Během tohoto hledání **posouvá prvky o jednu pozici** tak, aby vyplnily místo vybraného prvku a uvolnily jiné pro zařazení.
Při nalezení vhodného místa **zařadí vybraný prvek na uvolněné místo**.
Vzhledem k tomu, že jsme vybraný prvek rovnou **přesunuly**(žádné prohazování dvou prvků) a poté akci opakovali s každým dalším prvkem, není nutné dalšího cyklu pro opakování.




### Vizualizace

- Prvky, které prošly řazením se barví do zelená
- Prvky, které aktuálně prochází kontrolou a je zde možnost, že budou vybrány jako vhodná pozice pro prvek v paměti, se barví do červená.
- V paměti je vybraný prvek, pro který je nutné najít vhodnou pozici v částečně seřazené posloupnosti. Tento prvek je zobrazen mimo řadu čísel a je modrý.
- Některé prvky po skončení algoritmu zůstanou bílé, protože jsou již umístěny na správné pozici -> **řada je částečně seřazená => algoritmus je přirozený**

 

### Zdrojový kód

```

//Proved pro cele pole
for(int i = 0;  i< array.Length-1; i++)
{// Pozice pivotuint j = i + 1;// Urči hodnotu pivotuint pivot = array[j];//Dokud nejsme na začátku pole a pivot je vetší než aktuální prvek v setříděném poliwhile(j > 0 && pivot > array[j - 1]){	// Posuneme daný prvek o jedno místo doprava	array[j] = array[j - 1];	// Posuneme se o další prvek dal	j--;}// While skončil bud na začátku pole, nebo před prvním prvkem, který nesplnil podmínku// V obou případech vytvořil potřebné místo, na které umísti pivotarray[j] = pivot;
}

```


*Pozn. Je rychlý i na malých polích a jednoduchý na napsání, někdy výkonnější než Quick sort*

Jeho rozšířením je:  [Shell-sort](https://www.algoritmy.net/article/154/Shell-sort)


 Odkazy pro rozšíření daného téma:

[ITnetwork](http://www.itnetwork.cz/algoritmy/razeni/algoritmus-insertion-sort-trideni-cisel-podle-velikosti/)[Algoritmy.net](https://www.algoritmy.net/article/8/Insertion-sort)
## Quick sort

Algoritmus fungující na principu rozděl a panuj (nejde-li daný problém řešit, rozložíme ho na menší již řešitelné části).   
 V současnosti se jedná o jeden z nejrychlejších univerzálních řadících algoritmů.   
Základní vlastnosti

*   Stabilita: **nestabilní**
*   Složitost: **O(n * log n)**
*   Paměťová náročnost: v nejhorším případě **lineární**, po optimalizacích dodatečnou paměť skoro nepotřebuje
*   Přirozenost: **není přirozený**

### Princip řazení

Základní myšlenkou tohoto algoritmu je práce s pivotem. Pivot je jeden z prvků neseřazeného pole, se kterým porovnáváme okolní prvky.   
 Principiálně je postup takový:

*   Zvolíme pivot
*   Seřazení pole na prvky např. menší vlevo a větší vpravo od pivota tak, že se vymění pivot s vhodným prvkem 
*   Poté se vlevo i vpravo zvolí další pivoty a okolo nich se pole opět přeskupí
*   Algoritmus končí ve chvíli, kdy pro volbu pivota zbyla pouze jednoprvková pole

Činnost algoritmu je tedy rozdělena na dvě části a opakování:

*   Volba pivota
*   Seřazení okolí vůči pivotu
*   Opakování celého postupu pro části vlevo i vpravo od pivota

1.  #### Volba pivota

Využívá se několik způsobů volby.

    *   Nejjednodušší je zvolit náhodný prvek. Tento způsob je efektivní a často používaný.
    *   Sofistikovanější způsob je zvolit vždy prostřední prvek, nebo jemu blízký. Tím je možné dosáhnout nejefektivnější složitosti algoritmu   

* Pozn. u většiny algoritmů, které dělí pole, je nejlepší pole rozdělovat pokud možno na poloviny*

2.  #### Seřazení okolí pivota

Všechny prvky v okolí pivota se s daným pivotem porovnají a umístí se buď vlevo nebo vpravo od něj. Na pořadí nezáleží.

3.  #### Opakování postupu

Po volbě pivota a přeskupení prvků vlevo a vpravo od něj se rozdělilo původní pole na dvě části. Pro každou část opakuje znovu všechny kroky, tedy v každé části zvolíme pivot a opět pole přeskupíme.   
 Postupným dělením vstupního pole ve výsledku zůstanou pouze jednoprvková pole a v tu chvíli je již celé pole seřazené a algoritmus končí.   
 Nevýhodou může být při neefektivní volbě pivota vzrůstající paměťová náročnost.

### Vizualizace

![](images/QuickSoer.png)

### Zdrojový kód

Zdrojový kód je stejně jako postup algoritmu rozdělen na dvě části:

1.  Metoda na dělení pole na dvě části, která umisťuje prvek na správné místo a vrací jeho pozici - Partition(pole, zacatekLevehoPole, konecPravehoPole)
2.  Metoda pro rekurzivní volání dělení pole na části a hledání pivota - QuickSort_Recursive(pole, zacatekLevehoPole, konecPravehoPole)  

    <code class="language-C# ">/// Rozdělí pole na dvě části, seřadí je a celou proceduru opakuje
    /// <param name="arr">Pole k seřazení
    /// <param name="left">Začátek části pole
    /// <param name="right">Konec části pole
    public static void QuickSort(int[] arr, int left, int right)
    {
        // Rekurze se zastaví pokud je začátek a konec pole stejný => jednoprvková nebo prázdná pole
        if (left < right)="" {="" rozdělení="" pole="" na="" dvě="" části="" a="" získání="" pivota="" int="" partitionindex="Partition(arr," left,="" right);="" opakování="" pro="" obě="" části="" pole=""> rekurze
            QuickSort(arr, left, partitionIndex - 1);
            QuickSort(arr, partitionIndex + 1, right);
        }
    }
    /// Určí pivot, podle něj rozdělí pole na dvě části
    /// <param name="arr">Pole k seřazení
    /// <param name="left">Začátek části pole - index
    /// <param name="right">Konec části pole - index
    /// <returns>Vrací pozici pivota</returns>
    private static int Partition(int[] arr, int left, int right)
    {
        // Pivo je poslední prvek
        int pivot = arr[right];
        int temp;
        // Začátek pole
        int i = left;
        // Pro celou část pole
        for (int j = left; j < right;="" j++)="" {="" porovnání="" hodnoty="" s="" pivotem="" if="" (arr[j]=""><= pivot)="" {="" pokud="" je="" prvek="" menší="" než="" pivot,="" tak="" je="" vymění="" temp="arr[j];" arr[j]="arr[i];" arr[i]="temp;" i++;="" }="" }="" arr[right]="arr[i];" arr[i]="pivot;" return="" i;="" }=""></=></code>

*Pozn. Velká rychlost algoritmu je vyvážena jeho neefektivností na částečně seřazených polích*  

Vylepšenou verzí je QuickSort 3, který rozděluje pole na menší, stejné a větší prvky.   

 Odkazy pro rozšíření daného téma:  

 [ITnetwork](http://www.itnetwork.cz/algoritmy/razeni/algoritmus-quick-sort-razeni-cisel-podle-velikosti/)
 [Algoritmy.net](https://www.algoritmy.net/article/10/Quicksort)
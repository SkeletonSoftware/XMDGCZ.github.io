---
layout: post
title: "heap.php "
categories:
    -"csharp"
    -"csharp"
author: "David Malý"
--- 

 
## Heap sort


Jeden z nejefektivnějších řadících algoritmů. Vhodný pro běžné použití, protože má zaručeně neměnnou složitost.<br>
Základní vlastnosti


- Stabilita: **není stabilní**
- Složitost: **O(n \* log n)**
- Paměťová náročnost: **konstantní**
- Přirozenost: **není přirozený**


### Princip řazení


Máme k dispozici data ve formě pole.
<br>Na pole je nutné koukat jako na haldu (binární strom, hierarchická struktura s max 2 potomky na 1 rodiče). Stěžejní vlastností haldy je jistota, že **každý rodič je vždy větší nebo stejně velký** (nebo vždy menší dle návrhu) **než jeho potomci**.
<br>Na základě tohoto faktu stačí z haldy vždy odebrat Root (prvek, který je na vrcholu pyramidy) s naprostou jistotou, že v haldě nezbyl žádný větší prvek (nebo menší dle návrhu haldy).
<br>Postupně se berou prvky od konce haldy, nahrazují odebrané rooty a dle potřeby obnoví princip haldy (rodič > potomci). Tento postup se opakuje dokud v haldě nezbudou žádná data.

<br>Existují dva způsoby kam ukládat odebrané rooty.


1. Zavést nové pole o velikosti neseřazeného a do něj vkládat postupně odebrané prvky -> neefektivní
2. Jelikož je halda jen pohled na pole, je možné ho rozdělit na seřazená data a neseřazená.
Neseřazená část je ona halda, která se s každým odebraným prvkem zmenšuje. Dále po odebrání prvku je na jeho místo přemístěn poslední prvek neseřazeného pole. Tím vzniká místo na konci pole pro odebraný prvek.Seřazená část pole jsou odebrané prvky, které se do ní vkládají za sebou tak, jak byly odebrány.


### Halda


Pohled na data, která jsou zapsaná sekvenčně -> za sebou ve formě pole.
<br>Reprezentuje binární strom, kde má každý rodič maximálně dva potomky.


Vlastnosti haldy<br>
- **Každý rodič má maximálně 2 potomky**
- **Halda má dva druhy sestavení - od největšího prvku po nejmenší a naopak**
- **Zaručenost, že každý potomek je dle návrhu haldy vždy větší či stejný než jeho potomci**
- Není zaručeno, že jsou potomci vůči sobě ve správném pořadí



Špatně x Správně postavená halda

![](images/Heap2.png)


Ukázka hierarchie

![](images/Heap.png)
### Vizualizace
![](images/Heapsort-example.gif)<br>Heapsort-example.gif Autor: [Swfung8](//commons.wikimedia.org/w/index.php?title=User:Swfung8&amp;action=edit&amp;redlink=1 "User:Swfung8 (page does not exist)") – Vlastní dílo [CC BY-SA 3.0](http://creativecommons.org/licenses/by-sa/3.0 "Creative Commons Attribution-Share Alike 3.0")
### Zdrojový kód
<br>Zdrojový kód je rozdělen na 3 části<br>
1. Metoda pro vytvoření pohledu haldy na pole
2. Metoda pro odebrání rootu, posunutí posledního prvku pole na jeho místo
3. Metoda pro přeorganizování haldy




Maximum haldy je vždy na indexu 0.
<br>K získání rodiče se využívá vlastností haldy, kde je každý rodič v poli k nalezení na pozici **(i - 1)/2**, kde i je pozice potomka a dělení je celočíselné.
<br>Je-li i rodič, tak jeho potomci jsou na pozici: levý - **2 \* i + 1** a pravý - **2 \* i + 2**


```

/** řazení haldou (vzestupně)
* @param array pole k seřazeni
*/
public static void Heapsort(int[] array)
{// Pro všechny rodičefor (int i = array.Length / 2 - 1; i >= 0; i--){	// Oprav Haldu, aby splňovala své vlastnosti	RepairTop(array, array.Length - 1, i);}// Pro všechny prvky v halděfor (int i = array.Length - 1; i > 0; i--){	// Zaměň root s vybraným prvkem, root umísti na vhodnou pozici	int tmp = array[i];	array[i] = array[0];	array[0] = tmp;
	// Oprav haldu, po umístění posledního prvku jako root	RepairTop(array, i - 1, 0);}
}
/**
* Opravuje haldu tak, aby byl rodič vždy větší, či stejný jako potomek
* @param bottom - poslední index nesestřiženého pole
* @param topIndex -aktuálně kontrolovaný rodič
*/
private static void RepairTop(int[] array, int bottom, int topIndex)
{// Zapamatuj si aktuálního rodičeint tmp = array[topIndex];// Zjisti 1. potomkaint succ = topIndex * 2 + 1;// Je potomek ještě v nesestřiženém poli a je větší než jeho sourozenec?if (succ < bottom && array[succ] > array[succ + 1]) succ++; // Místo rodiče dosazujeme vždy většího z potomků// Dokud není konec haldy a větší z potomků je i větší než otec, tak je vymění// Opakujeme pro všechny potomky, aby se halda opravilawhile (succ <= bottom && tmp > array[succ]){	array[topIndex] = array[succ];	topIndex = succ;	// Posune ukazatel na 1. potomka dalšího rodiče	succ = succ* 2 + 1;	// Opět porovná oba potomky	if (succ < bottom && array[succ]> array[succ + 1]) succ++;}// Umístí na správné místo prvek, kvůli kterému se halda opravujearray[topIndex] = tmp;
}

```



*Pozn. Tento algoritmus je vhodný zejména díky jeho zaručeně neměnné složitosti. Touto vlastností předčí QuickSort, který v nejhorších případech zaostává.*

 Odkazy pro rozšíření daného téma:

[ITnetwork](http://www.itnetwork.cz/algoritmy/razeni/algoritmus-heap-sort-trideni-cisel-podle-velikosti/)[Algoritmy.net](https://www.algoritmy.net/article/17/Heapsort)
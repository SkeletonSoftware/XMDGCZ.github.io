## Bubble sort

Algoritmus na základě představy stoupajících bublinek.

Nejlehčí bublinky stoupají ke hladině vody rychleji než těžké, proto v určitou chvíli můžeme s jistotou říci, že nejlehčí bublinky budou u hladiny jako první a těžké budou oproti nim stále u dna. Z toho plyne domněnka, že se bublinky samy seřadí dle hmotnosti (velikosti).   
Základní vlastnosti

*   Stabilita: **stabilní**
*   Složitost: **O(n^2)**
*   Paměťová náročnost: **konstantní**
*   Přirozenost: **přirozený**

### Princip řazení

Máme k dispozici data ve formě pole.  

Algoritmus čte pole tolikrát, kolik má prvků. Každý prvek se porovná se sousedním prvkem a v případě potřeby se provede jejich záměna. Tímto způsobem dostaneme jeden prvek na konec pole -> **máme jistotu, že je daný prvek největší, nebo nejmenší z celého pole**.  

Seřadili jsme pouze jeden prvek, proto celý postup **opakujeme tolikrát, kolik má pole prvků mínus počet již správně seřazených** prvků.  

Počet cyklů se tedy snižuje s počtem již seřazených prvků -> seřazené prvky již nemusíme znovu kontrolovat.  

### Vizualizace

*   Větší ze dvou prvků se barví do červená, menší je zelený
*   Některé prvky zůstanou i po seřazení zelené, to je dáno právě stabilitou algoritmu, kde stejné prvky nejsou zpracovávány a dochází k jejich přeskočení.
*   Některé prvky si po určitou dobu zachovají bílou barvu, to je dáno tím, že v dané chvíli byly již správně seřazeny a mohly být tedy přeskočeny.
*   Limita cyklu se posouvá s počtem již seřazených prvků.
*   Šipka ukazuje na aktuálně největší prvek a po skončení řazení stále ukazuje na poslední prvek, který byl řazen.
 <iframe class="center" src="article/algs/animation.php#bubble" style="height: 300px;width:650px;" id="iframe"></iframe>   

### Zdrojový kód

    <code class="language-C# ">// Proved pro cele pole
    for(int i = 0; i < array.length-1;="" i++)="" {="" proved="" pro="" cele="" pole="" -="" pocet="" serazenych="" for(int="" j="0;" j="">< array.length="" -="" i="" -="" 1;="" j++)="" {="" radime="" vzestupně="" if(array[j+1]="">< array[j])="" {="" záměna="" prvku="" int="" temp="array[j];" array[j]="array[j" +="" 1];="" array[j="" +="" 1]="temp;" }="" }="" }=""></code>

Tento algoritmus je vhodný zejména kvůli jeho jednoduché implementaci. Spíše než k praktickému použití při řazení se hodí k účelům výuky algoritmizace.

*Pozn. Nevýhodou tohoto algoritmu je například: situace, kde je nejnižší prvek na konci seznamu. Takový prvek je nutné porovnat se všemi předchozími prvky, než se dostane na své místo. Takový problém vyřešil [ Shaker sort ](https://www.algoritmy.net/article/93/Shaker-sort). *

Odkazy pro rozšíření daného téma:  
 [Wikipedia](https://cs.wikipedia.org/wiki/Bublinkov%C3%A9_%C5%99azen%C3%AD)  
 [Algoritmy.net]( https://www.algoritmy.net/article/3/Bubble-sort) [Rabbit](http://www.algolist.net/Algorithms/Sorting/Bubble_sort)

 
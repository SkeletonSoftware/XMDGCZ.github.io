---
layout: post
title: "bubble.php "
categories:
    -"csharp"
    -"csharp"
author: "David Malý"
--- 


## Bubble sort



Algoritmus na základě představy stoupajících bublinek.



Nejlehčí bublinky stoupají ke hladině vody rychleji než těžké, proto v určitou chvíli můžeme s jistotou říci, že nejlehčí bublinky budou u hladiny jako první a těžké budou oproti nim stále u dna. Z toho plyne domněnka, že se bublinky samy seřadí dle hmotnosti (velikosti).<br>
Základní vlastnosti


- Stabilita: **stabilní**
- Složitost: **O(n^2)**
- Paměťová náročnost: **konstantní**
- Přirozenost: **přirozený**


### Princip řazení

<br>Máme k dispozici data ve formě pole.
<br>Algoritmus čte pole tolikrát, kolik má prvků. Každý prvek se porovná se sousedním prvkem a v případě potřeby se provede jejich záměna. Tímto způsobem dostaneme jeden prvek na konec pole -> **máme jistotu, že je daný prvek největší, nebo nejmenší z celého pole**.
<br>Seřadili jsme pouze jeden prvek, proto celý postup **opakujeme tolikrát, kolik má pole prvků mínus počet již správně seřazených** prvků.
<br>Počet cyklů se tedy snižuje s počtem již seřazených prvků -> seřazené prvky již nemusíme znovu kontrolovat.

### Vizualizace


- Větší ze dvou prvků se barví do červená, menší je zelený
- Některé prvky zůstanou i po seřazení zelené, to je dáno právě stabilitou algoritmu, kde stejné prvky nejsou zpracovávány a dochází k jejich přeskočení.
- Některé prvky si po určitou dobu zachovají bílou barvu, to je dáno tím, že v dané chvíli byly již správně seřazeny a mohly být tedy přeskočeny.
- Limita cyklu se posouvá s počtem již seřazených prvků.
- Šipka ukazuje na aktuálně největší prvek a po skončení řazení stále ukazuje na poslední prvek, který byl řazen.

 

### Zdrojový kód


```

// Proved pro cele pole
for(int i = 0; i < array.Length-1; i++)
{// Proved pro cele pole - pocet serazenychfor(int j = 0; j < array.Length - i - 1; j++){	// Radime vzestupně	if(array[j+1] < array[j])	{		// Záměna prvku		int temp = array[j];		array[j] = array[j + 1];		array[j + 1] = temp;	}}
}

```


Tento algoritmus je vhodný zejména kvůli jeho jednoduché implementaci. Spíše než k praktickému použití při řazení se hodí k účelům výuky algoritmizace.



*Pozn. Nevýhodou tohoto algoritmu je například: situace, kde je nejnižší prvek na konci seznamu. Takový prvek je nutné porovnat se všemi předchozími prvky, než se dostane na své místo. Takový problém vyřešil [Shaker sort](https://www.algoritmy.net/article/93/Shaker-sort).<br>*




Odkazy pro rozšíření daného téma:
[Wikipedia](https://cs.wikipedia.org/wiki/Bublinkov%C3%A9_%C5%99azen%C3%AD)
[Algoritmy.net](https://www.algoritmy.net/article/3/Bubble-sort)[Rabbit](http://www.algolist.net/Algorithms/Sorting/Bubble_sort)


## Merge sort

 Algoritmus fungující na principu rozděl a panuj (nejde-li daný problém řešit, rozložíme ho na menší již řešitelné části).   
 Pole rozděluje po polovinách tak dlouho, dokud nezbudou pouze jednotková pole. Pole o jednom prvku můžeme automaticky považovat za seřazené.  
 Poté stačí rozdělená pole spojit do jednoho ve správném pořadí.  

Základní vlastnosti:

*   Stabilita: **stabilní**
*   Složitost: **O(n * log n)**
*   Paměťová náročnost: **dle počtu prvků v poli**
*   Přirozenost: **přirozený**

### Princip řazení

Princip činnosti lze rozdělit do dvou aktivit:

1.  **Rozdělování **polí
2.  **Slévání** rozdělených polí ve správném pořadí

1.  #### Rozdělování pole

K dispozici máme jedno pole, které je potřeba seřadit. Toto pole rozdělíme na dvě poloviny (nevadí, že u lichých polí bude jedna část větší). Tyto dvě poloviny se opět rozdělí na další 2 (celkem tedy 4 části).  
 Tento postup opakujeme až do doby, kdy vzniknou pouze pole o jednom prvku (jednotková) a dělení se zastaví.  

 *Pozn. při prvním dělení vznikají dvě hlavní větve*

2.  #### Slévání polí dohromady

K dispozici máme vždy dvě pole. V 1. kroku jsou to pole jednotková (ta, která vznikla po dělení). U každého ze dvou polí si musíme pamatovat indexy prvku, který čteme.  

**Porovnáváme hodnoty dle indexů**, vybraný prvek umístíme do pomocné pomocného pole na pozici určenou **součtem indexů**, index u vybraného prvku posuneme o 1.  

Jednoprvková pole

	<table>
	  <tr>
		<th>Index</th>
		<td>0</td>
	  </tr>
	  <tr>
		<th>1. pole</th>
		<td>1</td>		
	  </tr>
	  <tr>
		<th>2. pole</th>
		<td>0</td>		
	  </tr>
	</table>

Mějme indexy 1. prvků z obou polí, jménem index1 a index2. Obě tyto proměnné jsou rovny nule.  
 Je prvek 1. pole na indexu[index1] > než prvek 2. pole na indexu[index2]? => **1 > 0 ?**  
 Jedna je větší než nula. Spočítáme součet indexů, tedy index1 + index2. Výsledkem je nula, což je zároveň index v pomocném poli.  
 Prvek, který prošel podmínkou (hodnota 1) umístíme na místo součtu indexů ( = 0 ) a přičteme k index1 +1, tento prvek ** odstraníme ** z původního pole.

Pomocné pole

	<table>
	  <tr>
		<th>Index</th>
		<td>0</td>
		<td>1</td>	
	  </tr>
	  <tr>
		<th>Pom. pole</th>
		<td class="blue">1</td>		
		<td></td>

	  </tr>
	</table>  

Protože nám zbyl už jen jeden prvek ( 0), zařadíme ho na konec pomocného pole. Čímž vzniklo seřazené pole.

Pomocné pole

	<table>
	  <tr>
		<th>Index</th>
		<td>0</td>
		<td>1</td>	
	  </tr>
	  <tr>
		<th>Pom. pole</th>
		<td>1</td>		
		<td class="blue">0</td>
	  </tr>
	</table>  

Tento postup se opakuje, dokud nezůstane jedno seřazené pole.

Po slití jednoprvkových polí

	<table>
	  <tr>
		<th>Index</th>
		<td>0</td>
		<td>1</td>	
	  </tr>
	  <tr>
		<th>1. pole</th>
		<td>1</td>		
		<td>0</td>
	  </tr>
	  <tr>
		<th>2. pole</th>
		<td>40</td>		
		<td>3</td>
	  </tr>
	</table>  

Je 1 > 40 ? Ne, není.  
 Součet indexů = 0  
 Umístíme hodnotu 40 na pozici 0, přičteme k index2 + 1 ( = 1 ) a 40 z původního pole odstraníme.

Pomocné pole

	<table>
	  <tr>
		<th>Index</th>
		<td>0</td>
		<td>1</td>	
		<td>2</td>	
		<td>3</td>	
	  </tr>
	  <tr>
		<th>Pom. pole</th>
		<td class="blue">40</td>		
		<td></td>
		<td></td>
		<td></td>
	  </tr>
	</table>

index1 = 0 a index2 = 1  
 Je pole1[index1] > pole2[index2] ? => 1 > 3 ?  
 Součet indexů = 1  
 Ne, není.  
 Umístíme hodnotu 3 na pozici 1, přičteme k index2 + 1 ( = 2 ) a 3 z původního pole odstraníme.

Pomocné pole

	<table>
	  <tr>
		<th>Index</th>
		<td>0</td>
		<td>1</td>	
		<td>2</td>	
		<td>3</td>	
	  </tr>
	  <tr>
		<th>Pom. pole</th>
		<td>40</td>		
		<td class="blue"> 3 </td>
		<td></td>
		<td></td>
	  </tr>
	</table>  

Tím jsme vyčerpali 2. pole a na konec pomocného přidáme zbývající prvky z 1. pole a vzniklo slité seřazené pole.  

Pomocné pole

	<table>
	  <tr>
		<th>Index</th>
		<td>0</td>
		<td>1</td>	
		<td>2</td>	
		<td>3</td>	
	  </tr>
	  <tr>
		<th>Pom. pole</th>
		<td>40</td>		
		<td> 3 </td>
		<td class="blue"> 1 </td>
		<td class="blue"> 0</td>
	  </tr>
	</table>  

### Vizualizace

![](images/Merge.png)

### Zdrojový kód

Zdrojový kód je stejně jako postup algoritmu rozdělen na dvě části:

1.  Metoda na dělení pole na dvě části
2.  Metoda na slití dvou polí do jednoho setříděného  

    <code class="language-C# ">// Rozdělení polí
    public static void merge_sort(int[] list)
    {
        if (list.Length <= 1)="" return;="" ukončení="" rekurze="" int="" center="list.Length" 2;="" zjištění="" středu="" pole,="" kvůli="" určení="" poloviny="" int[]="" left="new" int[center];="" deklarace="" a="" inicializace="" levé="" větve="" for="" (int="" i="0;" i=""></=>< center;="" i++)="" left[i]="list[i];" int[]="" right="new" int[list.length="" -="" center];="" deklarace="" a="" inicializace="" pravé="" větve="" for="" (int="" i="center;" i="">< list.length;="" i++)="" right[i="" -="" center]="list[i];" merge_sort(left);="" rekurzivní="" rozdělení="" polí="" na="" další="" poloviny="" merge_sort(right);="" merge(list,="" left,="" right);="" sliti="" rozdělených="" polí="" }="" slití="" dvou="" polí="" do="" jednoho="" parametry="" levá="" a="" pravá="" větev="" a="" celé="" pole,="" do="" kterého="" se="" dosadí="" slité="" pole="" public="" static="" void="" merge(int[]="" list,="" int[]="" left,="" int[]="" right)="" {="" indexy="" pro="" obě="" pole="" int="" i="0;" index="" pro="" 1.="" pole="" int="" j="0;" index="" pro="" 2.="" pole="" dokud="" neprojde="" jedno="" celé="" pole="" while="" ((i="">< left.length)="" &&="" (j="">< right.length))="" {="" vybrání="" menšího="" prvku,="" jeho="" dosazení="" do="" pole,="" posunutí="" indexu="" if="" (left[i]="">< right[j])="" {="" list[i="" +="" j]="left[i];" i++;="" }="" else="" {="" list[i="" +="" j]="right[j];" j++;="" }="" }="" zbytek="" z="" druhého="" pole="" přidáme="" za="" 1.="" seřazené="" pole="" if="" (i="">< left.length)//="" identifikace="" levé="" větve="" pole="" {="" while="" (i="">< left.length)="" {="" list[i="" +="" j]="left[i];" i++;="" }="" }="" else="" práce="" jen="" s="" pravou="" větví="" pole="" {="" while="" (j="">< right.length)="" {="" list[i="" +="" j]="right[j];" j++;="" }="" }="" }=""></code>

*Pozn. problémem tohoto algoritmu je nutnost pomocné paměti pro každé provedení funkce*   

 Odkazy pro rozšíření daného téma:  

 [itnetwork.cz](http://www.itnetwork.cz/algoritmy/razeni/algoritmus-merge-sort-trideni-cisel-podle-velikosti/)
 [Algoritmy.net](https://www.algoritmy.net/article/13/Merge-sort)
 
---
layout: post
title: "merge.php "
categories:
    -"csharp"
    -"csharp"
author: "David Malý"
--- 


## Merge sort


<br>Algoritmus fungující na principu rozděl a panuj (nejde-li daný problém řešit, rozložíme ho na menší již řešitelné části). 
<br>Pole rozděluje po polovinách tak dlouho, dokud nezbudou pouze jednotková pole. Pole o jednom prvku můžeme automaticky považovat za seřazené.
<br>Poté stačí rozdělená pole spojit do jednoho ve správném pořadí.

Základní vlastnosti:


- Stabilita: **stabilní**
- Složitost: **O(n \* log n)**
- Paměťová náročnost: **dle počtu prvků v poli**
- Přirozenost: **přirozený**


### Princip řazení


Princip činnosti lze rozdělit do dvou aktivit:


1. **Rozdělování**polí
2. **Slévání** rozdělených polí ve správném pořadí



#### - Rozdělování pole



K dispozici máme jedno pole, které je potřeba seřadit. Toto pole rozdělíme na dvě poloviny (nevadí, že u lichých polí bude jedna část větší). Tyto dvě poloviny se opět rozdělí na další 2 (celkem tedy 4 části).
Tento postup opakujeme až do doby, kdy vzniknou pouze pole o jednom prvku (jednotková) a dělení se zastaví.

*Pozn. při prvním dělení vznikají dvě hlavní větve*


#### - Slévání polí dohromady



K dispozici máme vždy dvě pole. V 1. kroku jsou to pole jednotková (ta, která vznikla po dělení). U každého ze dvou polí si musíme pamatovat indexy prvku, který čteme.

**Porovnáváme hodnoty dle indexů**, vybraný prvek umístíme do pomocné pomocného pole na pozici určenou**součtem indexů**, index u vybraného prvku posuneme o 1.



Jednoprvková pole



| Index | 0 |
| --- |
| 1. pole | 1 |
| --- |
| 2. pole | 0 |
| --- |




Mějme indexy 1. prvků z obou polí, jménem index1 a index2. Obě tyto proměnné jsou rovny nule.
Je prvek  1. pole na indexu[index1] > než prvek 2. pole na indexu[index2]? => **1 > 0 ?**
Jedna je větší než nula. Spočítáme součet indexů, tedy index1 + index2. Výsledkem je nula, což je zároveň index v pomocném poli.
Prvek, který prošel podmínkou (hodnota 1) umístíme na místo součtu indexů ( = 0 ) a přičteme k index1 +1, tento prvek **odstraníme** z původního pole.



Pomocné pole



| Index | 0 | 1 |
| --- |
| Pom. pole | 1 |  |
| --- |




Protože nám zbyl už jen jeden prvek ( 0), zařadíme ho na konec pomocného pole. Čímž vzniklo seřazené pole.



Pomocné pole



| Index | 0 | 1 |
| --- |
| Pom. pole | 1 | 0 |
| --- |




Tento postup se opakuje, dokud nezůstane jedno seřazené pole.




Po slití jednoprvkových polí



| Index | 0 | 1 |
| --- |
| 1. pole | 1 | 0 |
| --- |
| 2. pole | 40 | 3 |
| --- |




Je 1 > 40 ? Ne, není.
Součet indexů = 0
Umístíme hodnotu 40 na pozici 0, přičteme k index2 + 1 ( = 1 ) a 40 z původního pole odstraníme.




Pomocné pole



| Index | 0 | 1 | 2 | 3 |
| --- |
| Pom. pole | 40 |  |  |  |
| --- |




index1 = 0 a index2 = 1
Je pole1[index1] > pole2[index2] ? => 1 > 3 ?
Součet indexů = 1
Ne, není.
Umístíme hodnotu 3 na pozici 1, přičteme k index2 + 1 ( = 2 ) a 3 z původního pole odstraníme.



Pomocné pole



| Index | 0 | 1 | 2 | 3 |
| --- |
| Pom. pole | 40 |  3  |  |  |
| --- |




Tím jsme vyčerpali 2. pole a na konec pomocného přidáme zbývající prvky z 1. pole a vzniklo slité seřazené pole.



Pomocné pole



| Index | 0 | 1 | 2 | 3 |
| --- |
| Pom. pole | 40 |  3  |  1  |  0 |
| --- |






### Vizualizace
![](images/Merge.png)
### Zdrojový kód


Zdrojový kód je stejně jako postup algoritmu rozdělen na dvě části:


1. Metoda na dělení pole na dvě části
2. Metoda na slití dvou polí do jednoho setříděného



```

// Rozdělení polí
public static void merge_sort(int[] list)
{if (list.Length <= 1) return; // Ukončení rekurzeint center = list.Length / 2; // Zjištění středu pole, kvůli určení poloviny
int[] left = new int[center]; // deklarace a inicializace levé větvefor (int i = 0; i < center; i++) left[i] = list[i];
int[] right = new int[list.Length - center]; // deklarace a inicializace pravé větvefor (int i = center; i < list.Length; i++) right[i - center] = list[i];
merge_sort(left); // rekurzivní rozdělení polí na další polovinymerge_sort(right);merge(list, left, right); // sliti rozdělených polí
}


// Slití dvou polí do jednoho
// Parametry levá a pravá větev a celé pole, do kterého se dosadí slité pole
public static void merge(int[] list, int[] left, int[] right)
{// Indexy pro obě poleint i = 0; // index pro 1. poleint j = 0; // index pro 2. pole
// Dokud neprojde jedno celé polewhile ((i < left.Length) && (j < right.Length)){	// Vybrání menšího prvku, jeho dosazení do pole, posunutí indexu	if (left[i] < right[j])	{		list[i + j] = left[i];		i++;	}	else	{		list[i + j] = right[j];		j++;	}}
// Zbytek z druhého pole přidáme za 1. seřazené poleif (i < left.Length)// identifikace levé větve pole{	while (i < left.Length)	{		list[i + j] = left[i];		i++;	}}else // práce jen s pravou větví pole{	while (j < right.Length)	{		list[i + j] = right[j];		j++;	}}
}

```




*Pozn. problémem tohoto algoritmu je nutnost pomocné paměti pro každé provedení funkce*

 Odkazy pro rozšíření daného téma:

[itnetwork.cz](http://www.itnetwork.cz/algoritmy/razeni/algoritmus-merge-sort-trideni-cisel-podle-velikosti/)[Algoritmy.net](https://www.algoritmy.net/article/13/Merge-sort)
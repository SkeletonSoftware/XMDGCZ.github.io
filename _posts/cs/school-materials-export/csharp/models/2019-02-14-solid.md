---
layout: post
title: "SOLID "
categories:
    -"csharp"
    -"models"
author: "David Malý"
--- 


## Princip SOLID


Jan Půda



**SOLID** (single responsibility, open-closed, Liskov substitution, interface segregation, dependency inversion)



Je sada doporučení, principů a vodítek, sloužících k vytvoření kvalitnějšího objektového návrhu. Principy SOLID shromáždil a popsal **Robert C. Martin** (strýček Bob) kolem roku 2000.


### Přehled


Každé písmeno ve slově SOLID představuje jeden princip.


<!-- Table starts here -->

| Zkratka | Název | Popis |
| --- | --- | --- |
| S | Single responsibility principle | <br>                                      Třídy by měly mít jedinou zodpovědnost / jediný důvod ke změně.<br>                                   |
| O | Open/Closed principle | <br>                                      Třídy by měly být otevřené pro rozšiřování, ale uzavřené pro změny.<br>                                   |
| L | Liskov substitution principle | <br>                                      Podtřídy by měly být zaměnitelné s jejich bázovými třídami.<br>                                   |
| I | Interface segregation principle | <br>                                      Více specifických rozhraní je lepší než jedno univerzální rozhraní.<br>                                   |
| D | Dependency inversion principle | <br>                                      Závislost na abstrakcích, nikoliv na implementacích.<br>                                   |

### Podrobnější popis

#### SINGLE RESPONSIBILITY PRINCIPLE


Princip jedné zodpovědnosti - Tento princip nám říká, že každá třída nebo modul má mít jednu zodpovědnost a právě tato jedna zodpovědnost by měla být plně pokryta danou třídou/modulem.



Zodpovědností se zpravidla rozumí nějaká jednoduchá a oddělená funkcionalita. Největší výhodou tohoto principu je, že snižuje složitost systému a zvyšuje jeho pochopitelnost.



Příklad porušení principu:


```

class Book {
    private Name name;
    private Author author;
    private Content content;
    // ... getters
    // ... settters
    public void print() {
        // book printing code
    }
    public void read() {
        // book reading code
    }
}

```


Oprava podle principu:


```

class Book {
    private Name name;
    private Author author;
    private Content content;
    // ... getters
    // ... settters
}

```

```

class Printer {
    public void print(Book book) {
        // book printing code
    }
}

```

```

class Reader {
    public void read(Book book) {
        // book reading code
    }
}

```

#### OPEN/CLOSED PRINCIPLE


Princip Open/Closed - Tento princip nám říká, že každá softwarová entita jako třída, modul, nebo metoda by měla být otevřená pro rozšíření, ale uzavřená pro modifikaci.



Znamená to, že změnit její chování by mělo být možné bez toho, aby byl potřeba zásah do zdrojového kodu, například přidáváním jiných entit. Takový zásah do zdrojového kodu může totiž přinést mnoho komplikací. Většina realizací tohoto principu spočívá v použití dědičnosti.



Příklad porušení principu:


```

class Payment {
    public void pay(Method method, Money amount) {
        if (method.isCash()) {
            confirmPaidUsingCash(amount);
            printReceipt(amount);
            dispatchGoods();
        } else if (method.isTransfer()) {
            confirmPaidUsingTransfer(amount);
            printReceipt(amount);
            dispatchGoods();
        } else {
            throw new IllegalArgumentException("Unknown payment option.");
        }
    }
}

```


Oprava podle principu:


```

interface Method {
    void confirmPaymentReceived(Money amount);
}
class TransferMethod implements Method { /* ...confirmPaymentReceived... */ }
class CashMethod implements Method { /* ...confirmPaymentReceived... */ }

```

```

class Payment {
    public void pay(Method method, Money amount) {
        method.confirmPaymentReceived(amount);
        printReceipt(amount);
        dispatchGoods();
    }
}

```

#### LISKOV SUBSTITUTION PRINCIPLE


Liskovové princip zaměnitelnosti - Tento princip hovoří o vzájemném nahrazování dvou tříd. Uvěďme si to na příkladu, kdy máme třídu **A** a třídu **B**. Třída **B** je potomkem třídy **A**, takže třída **B** musí být použitelná všude, kde je vyžadována třída **A** bez toho, aniž by o tom nadřazená třída věděla.



Tento princip opět implikuje použití dědičnosti.


#### INTERFACE SEGREGATION PRINCIPLE


Princip oddělení rozhraní - Tento princip nám říká, že každé rozhraní by mělo být co nejmenší možné. Třídy by měly záviset pouze na těch rozhraních, která používají.



Když rozhraní přesáhne rozumnou velikost, musí se rozdělit do několika dalších, užších. Touto změnou se zasažené třídy přepracují tak, aby implementovaly minimální potřebnou podmnožinu původních rozhraní.



Příklad porušení principu:


```

interface Lifecycle {
    void start();
    void stop();
}

```


Oprava podle principu:


```

interface Startable {
    void start();
}

```

```

interface Stoppable{
    void stop();
}

```

#### DEPENDENCY INVERSION PRINCIPLE


Princip inverze závislosti - Tento princip nám říká, že moduly na vyšší úrovni by neměly záviset na modulech nízkoúrovňových. Oba by měly záviset na abstrakcích.  A dále, abstrakce by neměly záviset na implementačních detailech, ale naopak - detaily by měly záviset na abstrakcích.



Například, když vyšší úroveň provádí rozhodnutí a jeho realizací pověřuje moduly na nižší úrovni, může se po změně nižší úrovně změnit funkce i vyšší úrovně. To by se ale nemělo stát - snižuje to znovupoužitelnost vysokoúrovňových modulů, které by měly stát odděleně od modulů nízkoúrovňových.


### Zdroje a další informace


[Wikipedia - SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design))



[Zdroják.cz - SOLID](https://www.zdrojak.cz/clanky/navrhove-principy-solid/)



Robert C. Martin: Čistý kód, Computer Press a.s., 2009, ISBN-978–80–251–2285–3

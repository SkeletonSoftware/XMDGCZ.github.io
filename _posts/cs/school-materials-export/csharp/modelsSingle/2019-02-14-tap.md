---
layout: post
title: "Task-based Asynchronous Pattern "
categories:
    -"csharp"
    -"modelsSingle"
author: "David Malý"
--- 


## Task-based Asynchronous Pattern (TAP)


Michal Zatloukal



Pattern pro moderní asynchronní programování s automatickou správu multithreadingu .NET Frameworkem.



Task-based Asynchronous Pattern (TAP) využívá datové typy *System.Threading.Tasks.Task* a *System.Threading.Tasks.Task<TResult>* k reprezentaci libovolné asynchronní operace. Je tedy nutné naimportovovat namespace *System.Threading.Tasks.*



Inicializace a dokončení asynchronní operace je na rozdíl od jiných patternů v TAP reprezentováno jednou metodou. Asynchronní metody v TAP se pojmenovávají s příponou “Async” (např. “NázevMetodyAsync”).



Metody v TAP vrací buď *System.Threading.Tasks.Task* (pro datový typ *void* odpovídající synchronní metody), nebo *System.Threading.Tasks.Task<TResult>* (pro jakýkoliv jiný návratový datový typ). Asynchronní metoda založená na TAP by měla obsahovat minimální množství synchronní práce, obvykle jen validaci parametrů či inicializaci asynchronní operace před tím, než vrací výsledný *Task.*



Tento pattern je moderní a jednoduchý na implementaci. Implementují se klíčová slova *async* a *await*, zatímco framework se postará o multithreading.


### Příklad asynchronní metody


Pro demonstraci funkcionalit TAP si představme dlouho běžící synchronní metodu.


```

public static IEnumerable<int> getPrimes(int min, int count)
{return Enumerable.Range(min, count).Where	(n => Enumerable.Range(2, (int)Math.Sqrt(n) - 1).All(i =>		n % i > 0));
}


```


V závislosti na parametrech tato metoda může trvat dlouhou dobu.



Změnění této metody na asynchronní lze dosáhnout změnou návratového typu metody.


```

public static Task<IEnumerable<int>> getPrimesAsync(int min, int count)
{
     return Task.Run (()=> Enumerable.Range(min, count).Where
     	(n => Enumerable.Range(2, (int)Math.Sqrt(n) - 1).All(i =>
    		n % i > 0)));
}


```


Nyní je návratový datový typ *Task<T>* a proto lze tuto metodu volat s použitím *await*, což znamená, že při volání metody se zpracovává okamžitě další kód a průběh metody nezastaví na čas aplikaci. Nečekáme tedy na odpověď přímo, ale necháme, ať se metoda ozve sama, až bude odpověď připravená.



Metoda *getPrimesAsync* je poté níže volána asynchronně.


```

private static async void PrintPrimaryNumbersAsync()
{
    for (int i = 0; i < 10; i++)
    {
        var result = await getPrimesAsync(i * 100000 + 1, i * 1000000);
        result.ToList().ForEach(x => Trace.WriteLine(x));
    }
}


```


Všiměte si nutnosti klíčového slova *async* v metodě *PrintPrimaryNumbersAsync*, která volá asynchronně metodu *getPrimesAsync* pomocí *await*. Jakmile je zavolána, zpracování v hlavním vlákně postupuje okamžitě dále a hlavní vlákno se postará o zpracování výstupu až když vedlejší vlákno dokončí zpracování metody (v tomto případě metoda najde prvočísla v zadaném rozsahu).



Program pak vypadá takto:


```

static void Main(string[] args)
{
    PrintPrimaryNumbersAsync();
    Trace.WriteLine("Any Key to terminate!!");
}


```

### Příklad asynchronní práce s API


Třída webového klienta obsahuje asynchronní metody:


```

class Rest
{
    public async Task<ObservableCollection<Person>> GetPersonsListAsync()
    {
        string url = "http://example.com/persons/list.php";
        var client = new RestClient(url);

        var request = new RestRequest("", Method.POST);
        IRestResponse response = client.Execute(request);

        IParser parser = new JsonParser();
        return await parser.DeserializeAsync<ObservableCollectio<Person>>(response.Content);
    }

    public async Task CreatePersonAsync(Person newPerson)
    {
        JsonParser parser = new JsonParser();
        string personString = await parser.SerializeAsync<Person>(newPerson);
        await Task.Run(() =>
        {
            string url = "http://example.com/persons/create.php";
            var client = new RestClient(url);

            var request = new RestRequest("", Method.POST);
            request.AddParameter("Person", personString);

            IRestResponse response = client.Execute(request);
        });
    }
}


```


V programu jsou metody třídy dále volány asynchronně:


```

Rest webClient = new Rest();
await webClient.CreatePersonAsync(person);
...
Rest webClient = new Rest();
Persons = await webClient.GetPersonsListAsync();


```

#### Užitečné odkazy
[Microsoft TAP](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)[Microsoft implementace TAP](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern)[Microsoft asynchronní programování](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/)[Ukázka TAP](https://www.codeproject.com/Tips/591586/Asynchronous-Programming-in-Csharp-5-0-using-async)
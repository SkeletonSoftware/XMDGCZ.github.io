---
layout: post
title: "Adapter "
categories:
    - "csharp"
    - "modelsSingle"
sort_index: 0
author: "David Malý"
--- 


##   Proxy Pattern


Zdeněk Hochman



    Proxy pattern někdy nazýván jako wrapper se používá pro práci s komponentou nestabilní, nebo nekompatibilní s rozhraním.    Jinak řečeno. Pokud bychom měli komponentu na 100 místech v programu, bylo by potřeba při každé nové verzi přepisovat kód na mnoha místech.    Adapter komponentu obalí vlastním rozhraním a aplikace je tak zcela odstíněna od původního rozhraní komponenty. Kdykoliv se toto rozhraní změní, stačí pouze aktualizovat adapter.


### Logika


    Pattern je prostředník mezi naším rozhraním a rozhraním komponenty. Klient je součast nášeho systému, která volá naše rohraní.    Adaptee je komponenta, jejíž rozhraní je nestabilní, nebo nekompatibilní. Naše rozhraní je definováno v třídě Adapter, která zajišťuje transformaci metod od Klient do Adaptee.

![Pattern](images/Pattern.png)

    Pattern je možné vylepšít přidáním abstraktní třídy Cíl. Adapter dědí z abstraktní třídy Cíl. Smysl abstraktní třídy je ten, aby bylo možné Adaptér snáze vyměnit za jiný při zachování kompatibility.

![Pattern-Modifikace](images/Pattern2.png)
### Zdrojový kód pro implementaci

```

public class Client
{private ITarget target;
public Client(ITarget target){	this.target = target;}
public void MakeRequest(){	target.MethodA();}
}

public interface ITarget
{void MethodA();
}

public class Adapter : Adaptee, ITarget
{public void MethodA(){	MethodB();}
}

public class Adaptee
{public void MethodB(){	Console.WriteLine("MethodB() is called");}
}

```

### Vzorový kód


    Vytvoříme jednoduchý příklad, který lze použít v praxi.
    V tomto případě budeme zobrazovat databázi zaměstnanců s použitím Adapter vzoru.
    Nejdříve založíme třídu ThirdPartyEmployee, která reprezentuje třídu Adaptee. Neboli tu, kterou poté budeme obalovat vlastním rozhraním.


```

// 'Adaptee' class
class ThirdPartyEmployee
{public List GetEmployeeList(){	List EmployeeList = new List();	EmployeeList.Add("Tom");	EmployeeList.Add("Sam");	EmployeeList.Add("Jack");	EmployeeList.Add("Mary");	return EmployeeList;}
}

```


Dále je třeba vytvořit interface ITarget který reprezentuje třídu Cíl.


```

//'ITarget' interface
interface ITarget
{List GetEmployees();
}

```


Následně vytvoříme třídu Adapter. Což je vlastně to naše rozhraní kterým obalujeme třídu Adaptee.


```

// 'Adapter' class
class EmployeeAdapter : ThirdPartyEmployee, ITarget
{public List GetEmployees(){	return GetEmployeeList();}
}

```


A jako poslední vytvoříme třídu Client která zavolá třídu Adapter a vypíše všechny zaměstnance.


```

class Client
{static void Main(string[] args){	ITarget adapter = new EmployeeAdapter();	foreach (string employee in adapter.GetEmployees())	{		Console.WriteLine(employee);	}	Console.ReadLine();}
}

```


Takhle by poté měl vypadat výstup v konzoli

![Result](images/Result.png)
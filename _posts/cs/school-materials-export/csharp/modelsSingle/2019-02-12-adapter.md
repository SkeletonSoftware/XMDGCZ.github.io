##   Proxy Pattern

Zdeněk Hochman

 Proxy pattern někdy nazýván jako wrapper se používá pro práci s komponentou nestabilní, nebo nekompatibilní s rozhraním. Jinak řečeno. Pokud bychom měli komponentu na 100 místech v programu, bylo by potřeba při každé nové verzi přepisovat kód na mnoha místech. Adapter komponentu obalí vlastním rozhraním a aplikace je tak zcela odstíněna od původního rozhraní komponenty. Kdykoliv se toto rozhraní změní, stačí pouze aktualizovat adapter. 

### Logika

 Pattern je prostředník mezi naším rozhraním a rozhraním komponenty. Klient je součast nášeho systému, která volá naše rohraní. Adaptee je komponenta, jejíž rozhraní je nestabilní, nebo nekompatibilní. Naše rozhraní je definováno v třídě Adapter, která zajišťuje transformaci metod od Klient do Adaptee. 

![Pattern](images/Pattern.png)

 Pattern je možné vylepšít přidáním abstraktní třídy Cíl. Adapter dědí z abstraktní třídy Cíl. Smysl abstraktní třídy je ten, aby bylo možné Adaptér snáze vyměnit za jiný při zachování kompatibility. 

![Pattern-Modifikace](images/Pattern2.png)

### Zdrojový kód pro implementaci

    <code class="language-C# ">public class Client
    {
        private ITarget target;

        public Client(ITarget target)
        {
            this.target = target;
        }

        public void MakeRequest()
        {
            target.MethodA();
        }
    }

    public interface ITarget
    {
        void MethodA();
    }

    public class Adapter : Adaptee, ITarget
    {
        public void MethodA()
        {
            MethodB();
        }
    }

    public class Adaptee
    {
        public void MethodB()
        {
            Console.WriteLine("MethodB() is called");
        }
    }</code>

### Vzorový kód

 Vytvoříme jednoduchý příklad, který lze použít v praxi.  
 V tomto případě budeme zobrazovat databázi zaměstnanců s použitím Adapter vzoru.  
 Nejdříve založíme třídu ThirdPartyEmployee, která reprezentuje třídu Adaptee. Neboli tu, kterou poté budeme obalovat vlastním rozhraním. 

    <code class="language-C# ">// 'Adaptee' class
    class ThirdPartyEmployee
    {
        public List<string> GetEmployeeList()
        {
            List<string> EmployeeList = new List<string>();
            EmployeeList.Add("Tom");
            EmployeeList.Add("Sam");
            EmployeeList.Add("Jack");
            EmployeeList.Add("Mary");
            return EmployeeList;
        }
    }</string></string></string></code>

Dále je třeba vytvořit interface ITarget který reprezentuje třídu Cíl.

    <code class="language-C# ">//'ITarget' interface
    interface ITarget
    {
        List<string> GetEmployees();
    }</string></code>

Následně vytvoříme třídu Adapter. Což je vlastně to naše rozhraní kterým obalujeme třídu Adaptee.

    <code class="language-C# ">// 'Adapter' class
    class EmployeeAdapter : ThirdPartyEmployee, ITarget
    {
        public List<string> GetEmployees()
        {
            return GetEmployeeList();
        }
    }</string></code>

A jako poslední vytvoříme třídu Client která zavolá třídu Adapter a vypíše všechny zaměstnance.

    <code class="language-C# ">class Client
    {
        static void Main(string[] args)
        {
            ITarget adapter = new EmployeeAdapter();
            foreach (string employee in adapter.GetEmployees())
            {
                Console.WriteLine(employee);
            }
            Console.ReadLine();
        }
    }</code>

Takhle by poté měl vypadat výstup v konzoli

![Result](images/Result.png)